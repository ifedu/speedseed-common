var fs = require('fs');
var path = require('path');
var common = require('./common');
var cp = require('./cp');
var rm = require('./rm');
common.register('mv', _mv, {
    cmdOptions: {
        'f': '!no_force',
        'n': 'no_force',
    },
});
// Checks if cureent file was created recently
function checkRecentCreated(sources, index) {
    var lookedSource = sources[index];
    return sources.slice(0, index).some(function (src) {
        return path.basename(src) === path.basename(lookedSource);
    });
}
//@
//@ ### mv([options ,] source [, source ...], dest')
//@ ### mv([options ,] source_array, dest')
//@ Available options:
//@
//@ + `-f`: force (default behavior)
//@ + `-n`: no-clobber
//@
//@ Examples:
//@
//@ ```javascript
//@ mv('-n', 'file', 'dir/');
//@ mv('file1', 'file2', 'dir/');
//@ mv(['file1', 'file2'], 'dir/'); // same as above
//@ ```
//@
//@ Moves files.
function _mv(options, sources, dest) {
    // Get sources, dest
    if (arguments.length < 3) {
        common.error('missing <source> and/or <dest>');
    }
    else if (arguments.length > 3) {
        sources = [].slice.call(arguments, 1, arguments.length - 1);
        dest = arguments[arguments.length - 1];
    }
    else if (typeof sources === 'string') {
        sources = [sources];
    }
    else {
        // TODO(nate): figure out if we actually need this line
        common.error('invalid arguments');
    }
    var exists = fs.existsSync(dest);
    var stats = exists && fs.statSync(dest);
    // Dest is not existing dir, but multiple sources given
    if ((!exists || !stats.isDirectory()) && sources.length > 1) {
        common.error('dest is not a directory (too many sources)');
    }
    // Dest is an existing file, but no -f given
    if (exists && stats.isFile() && options.no_force) {
        common.error('dest file already exists: ' + dest);
    }
    sources.forEach(function (src, srcIndex) {
        if (!fs.existsSync(src)) {
            common.error('no such file or directory: ' + src, { continue: true });
            return; // skip file
        }
        // If here, src exists
        // When copying to '/path/dir':
        //    thisDest = '/path/dir/file1'
        var thisDest = dest;
        if (fs.existsSync(dest) && fs.statSync(dest).isDirectory()) {
            thisDest = path.normalize(dest + '/' + path.basename(src));
        }
        var thisDestExists = fs.existsSync(thisDest);
        if (thisDestExists && checkRecentCreated(sources, srcIndex)) {
            // cannot overwrite file created recently in current execution, but we want to continue copying other files
            if (!options.no_force) {
                common.error("will not overwrite just-created '" + thisDest + "' with '" + src + "'", { continue: true });
            }
            return;
        }
        if (fs.existsSync(thisDest) && options.no_force) {
            common.error('dest file already exists: ' + thisDest, { continue: true });
            return; // skip file
        }
        if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {
            common.error('cannot move to self: ' + src, { continue: true });
            return; // skip file
        }
        try {
            fs.renameSync(src, thisDest);
        }
        catch (e) {
            /* istanbul ignore next */
            if (e.code === 'EXDEV') {
                // If we're trying to `mv` to an external partition, we'll actually need
                // to perform a copy and then clean up the original file. If either the
                // copy or the rm fails with an exception, we should allow this
                // exception to pass up to the top level.
                cp('-r', src, thisDest);
                rm('-rf', src);
            }
        }
    }); // forEach(src)
    return '';
} // mv
module.exports = _mv;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQzpcXFVzZXJzXFxpZmVkdVxcQXBwRGF0YVxcUm9hbWluZ1xcbnZtXFx2OC40LjBcXG5vZGVfbW9kdWxlc1xcZ2VuZXJhdG9yLXNwZWVkc2VlZFxcbm9kZV9tb2R1bGVzXFxzaGVsbGpzXFxzcmNcXG12LmpzIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGlmZWR1XFxBcHBEYXRhXFxSb2FtaW5nXFxudm1cXHY4LjQuMFxcbm9kZV9tb2R1bGVzXFxnZW5lcmF0b3Itc3BlZWRzZWVkXFxub2RlX21vZHVsZXNcXHNoZWxsanNcXHNyY1xcbXYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDakMsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pCLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV6QixNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7SUFDekIsVUFBVSxFQUFFO1FBQ1YsR0FBRyxFQUFFLFdBQVc7UUFDaEIsR0FBRyxFQUFFLFVBQVU7S0FDaEI7Q0FDRixDQUFDLENBQUM7QUFFSCw4Q0FBOEM7QUFDOUMsNEJBQTRCLE9BQU8sRUFBRSxLQUFLO0lBQ3hDLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRztRQUMvQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELEdBQUc7QUFDSCxvREFBb0Q7QUFDcEQsMkNBQTJDO0FBQzNDLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0gsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0gsYUFBYTtBQUNiLEdBQUc7QUFDSCxpQkFBaUI7QUFDakIsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyxvREFBb0Q7QUFDcEQsT0FBTztBQUNQLEdBQUc7QUFDSCxnQkFBZ0I7QUFDaEIsYUFBYSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUk7SUFDakMsb0JBQW9CO0lBQ3BCLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixNQUFNLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLHVEQUF1RDtRQUN2RCxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakMsSUFBSSxLQUFLLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFeEMsdURBQXVEO0lBQ3ZELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUQsTUFBTSxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCw0Q0FBNEM7SUFDNUMsRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNqRCxNQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRCxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLFFBQVE7UUFDckMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QixNQUFNLENBQUMsS0FBSyxDQUFDLDZCQUE2QixHQUFHLEdBQUcsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLE1BQU0sQ0FBQyxDQUFDLFlBQVk7UUFDdEIsQ0FBQztRQUVELHNCQUFzQjtRQUV0QiwrQkFBK0I7UUFDL0Isa0NBQWtDO1FBQ2xDLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztRQUNwQixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzNELFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFFRCxJQUFJLGNBQWMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTdDLEVBQUUsQ0FBQyxDQUFDLGNBQWMsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVELDJHQUEyRztZQUMzRyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUN0QixNQUFNLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxHQUFHLFFBQVEsR0FBRyxVQUFVLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzVHLENBQUM7WUFDRCxNQUFNLENBQUM7UUFDVCxDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNoRCxNQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixHQUFHLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sQ0FBQyxDQUFDLFlBQVk7UUFDdEIsQ0FBQztRQUVELEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELE1BQU0sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEdBQUcsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDaEUsTUFBTSxDQUFDLENBQUMsWUFBWTtRQUN0QixDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0gsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDWCwwQkFBMEI7WUFDMUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUN2Qix3RUFBd0U7Z0JBQ3hFLHVFQUF1RTtnQkFDdkUsK0RBQStEO2dCQUMvRCx5Q0FBeUM7Z0JBQ3pDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUN4QixFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ2pCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlO0lBQ25CLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDWixDQUFDLENBQUMsS0FBSztBQUNQLE1BQU0sQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgY3AgPSByZXF1aXJlKCcuL2NwJyk7XG52YXIgcm0gPSByZXF1aXJlKCcuL3JtJyk7XG5cbmNvbW1vbi5yZWdpc3RlcignbXYnLCBfbXYsIHtcbiAgY21kT3B0aW9uczoge1xuICAgICdmJzogJyFub19mb3JjZScsXG4gICAgJ24nOiAnbm9fZm9yY2UnLFxuICB9LFxufSk7XG5cbi8vIENoZWNrcyBpZiBjdXJlZW50IGZpbGUgd2FzIGNyZWF0ZWQgcmVjZW50bHlcbmZ1bmN0aW9uIGNoZWNrUmVjZW50Q3JlYXRlZChzb3VyY2VzLCBpbmRleCkge1xuICB2YXIgbG9va2VkU291cmNlID0gc291cmNlc1tpbmRleF07XG4gIHJldHVybiBzb3VyY2VzLnNsaWNlKDAsIGluZGV4KS5zb21lKGZ1bmN0aW9uIChzcmMpIHtcbiAgICByZXR1cm4gcGF0aC5iYXNlbmFtZShzcmMpID09PSBwYXRoLmJhc2VuYW1lKGxvb2tlZFNvdXJjZSk7XG4gIH0pO1xufVxuXG4vL0Bcbi8vQCAjIyMgbXYoW29wdGlvbnMgLF0gc291cmNlIFssIHNvdXJjZSAuLi5dLCBkZXN0Jylcbi8vQCAjIyMgbXYoW29wdGlvbnMgLF0gc291cmNlX2FycmF5LCBkZXN0Jylcbi8vQCBBdmFpbGFibGUgb3B0aW9uczpcbi8vQFxuLy9AICsgYC1mYDogZm9yY2UgKGRlZmF1bHQgYmVoYXZpb3IpXG4vL0AgKyBgLW5gOiBuby1jbG9iYmVyXG4vL0Bcbi8vQCBFeGFtcGxlczpcbi8vQFxuLy9AIGBgYGphdmFzY3JpcHRcbi8vQCBtdignLW4nLCAnZmlsZScsICdkaXIvJyk7XG4vL0AgbXYoJ2ZpbGUxJywgJ2ZpbGUyJywgJ2Rpci8nKTtcbi8vQCBtdihbJ2ZpbGUxJywgJ2ZpbGUyJ10sICdkaXIvJyk7IC8vIHNhbWUgYXMgYWJvdmVcbi8vQCBgYGBcbi8vQFxuLy9AIE1vdmVzIGZpbGVzLlxuZnVuY3Rpb24gX212KG9wdGlvbnMsIHNvdXJjZXMsIGRlc3QpIHtcbiAgLy8gR2V0IHNvdXJjZXMsIGRlc3RcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgY29tbW9uLmVycm9yKCdtaXNzaW5nIDxzb3VyY2U+IGFuZC9vciA8ZGVzdD4nKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgIHNvdXJjZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGRlc3QgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VzID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZXMgPSBbc291cmNlc107XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyhuYXRlKTogZmlndXJlIG91dCBpZiB3ZSBhY3R1YWxseSBuZWVkIHRoaXMgbGluZVxuICAgIGNvbW1vbi5lcnJvcignaW52YWxpZCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIHZhciBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRlc3QpO1xuICB2YXIgc3RhdHMgPSBleGlzdHMgJiYgZnMuc3RhdFN5bmMoZGVzdCk7XG5cbiAgLy8gRGVzdCBpcyBub3QgZXhpc3RpbmcgZGlyLCBidXQgbXVsdGlwbGUgc291cmNlcyBnaXZlblxuICBpZiAoKCFleGlzdHMgfHwgIXN0YXRzLmlzRGlyZWN0b3J5KCkpICYmIHNvdXJjZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbW1vbi5lcnJvcignZGVzdCBpcyBub3QgYSBkaXJlY3RvcnkgKHRvbyBtYW55IHNvdXJjZXMpJyk7XG4gIH1cblxuICAvLyBEZXN0IGlzIGFuIGV4aXN0aW5nIGZpbGUsIGJ1dCBubyAtZiBnaXZlblxuICBpZiAoZXhpc3RzICYmIHN0YXRzLmlzRmlsZSgpICYmIG9wdGlvbnMubm9fZm9yY2UpIHtcbiAgICBjb21tb24uZXJyb3IoJ2Rlc3QgZmlsZSBhbHJlYWR5IGV4aXN0czogJyArIGRlc3QpO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIHNyY0luZGV4KSB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHNyYykpIHtcbiAgICAgIGNvbW1vbi5lcnJvcignbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeTogJyArIHNyYywgeyBjb250aW51ZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybjsgLy8gc2tpcCBmaWxlXG4gICAgfVxuXG4gICAgLy8gSWYgaGVyZSwgc3JjIGV4aXN0c1xuXG4gICAgLy8gV2hlbiBjb3B5aW5nIHRvICcvcGF0aC9kaXInOlxuICAgIC8vICAgIHRoaXNEZXN0ID0gJy9wYXRoL2Rpci9maWxlMSdcbiAgICB2YXIgdGhpc0Rlc3QgPSBkZXN0O1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGRlc3QpICYmIGZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRoaXNEZXN0ID0gcGF0aC5ub3JtYWxpemUoZGVzdCArICcvJyArIHBhdGguYmFzZW5hbWUoc3JjKSk7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNEZXN0RXhpc3RzID0gZnMuZXhpc3RzU3luYyh0aGlzRGVzdCk7XG5cbiAgICBpZiAodGhpc0Rlc3RFeGlzdHMgJiYgY2hlY2tSZWNlbnRDcmVhdGVkKHNvdXJjZXMsIHNyY0luZGV4KSkge1xuICAgICAgLy8gY2Fubm90IG92ZXJ3cml0ZSBmaWxlIGNyZWF0ZWQgcmVjZW50bHkgaW4gY3VycmVudCBleGVjdXRpb24sIGJ1dCB3ZSB3YW50IHRvIGNvbnRpbnVlIGNvcHlpbmcgb3RoZXIgZmlsZXNcbiAgICAgIGlmICghb3B0aW9ucy5ub19mb3JjZSkge1xuICAgICAgICBjb21tb24uZXJyb3IoXCJ3aWxsIG5vdCBvdmVyd3JpdGUganVzdC1jcmVhdGVkICdcIiArIHRoaXNEZXN0ICsgXCInIHdpdGggJ1wiICsgc3JjICsgXCInXCIsIHsgY29udGludWU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmModGhpc0Rlc3QpICYmIG9wdGlvbnMubm9fZm9yY2UpIHtcbiAgICAgIGNvbW1vbi5lcnJvcignZGVzdCBmaWxlIGFscmVhZHkgZXhpc3RzOiAnICsgdGhpc0Rlc3QsIHsgY29udGludWU6IHRydWUgfSk7XG4gICAgICByZXR1cm47IC8vIHNraXAgZmlsZVxuICAgIH1cblxuICAgIGlmIChwYXRoLnJlc29sdmUoc3JjKSA9PT0gcGF0aC5kaXJuYW1lKHBhdGgucmVzb2x2ZSh0aGlzRGVzdCkpKSB7XG4gICAgICBjb21tb24uZXJyb3IoJ2Nhbm5vdCBtb3ZlIHRvIHNlbGY6ICcgKyBzcmMsIHsgY29udGludWU6IHRydWUgfSk7XG4gICAgICByZXR1cm47IC8vIHNraXAgZmlsZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmcy5yZW5hbWVTeW5jKHNyYywgdGhpc0Rlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoZS5jb2RlID09PSAnRVhERVYnKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIHRyeWluZyB0byBgbXZgIHRvIGFuIGV4dGVybmFsIHBhcnRpdGlvbiwgd2UnbGwgYWN0dWFsbHkgbmVlZFxuICAgICAgICAvLyB0byBwZXJmb3JtIGEgY29weSBhbmQgdGhlbiBjbGVhbiB1cCB0aGUgb3JpZ2luYWwgZmlsZS4gSWYgZWl0aGVyIHRoZVxuICAgICAgICAvLyBjb3B5IG9yIHRoZSBybSBmYWlscyB3aXRoIGFuIGV4Y2VwdGlvbiwgd2Ugc2hvdWxkIGFsbG93IHRoaXNcbiAgICAgICAgLy8gZXhjZXB0aW9uIHRvIHBhc3MgdXAgdG8gdGhlIHRvcCBsZXZlbC5cbiAgICAgICAgY3AoJy1yJywgc3JjLCB0aGlzRGVzdCk7XG4gICAgICAgIHJtKCctcmYnLCBzcmMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIGZvckVhY2goc3JjKVxuICByZXR1cm4gJyc7XG59IC8vIG12XG5tb2R1bGUuZXhwb3J0cyA9IF9tdjtcbiJdfQ==